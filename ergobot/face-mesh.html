<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
</head>

<body>
  <div class="container">
    <video class="input_video"></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>
  </div>
</body>
</html>
<script type="module">
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    var distanceAlertCount = 0;
    var frame_counter =0;	
    var CEF_COUNTER =0;
    var TOTAL_BLINKS =0;
    var CLOSED_EYES_FRAME =1;
    var countDownDate = new Date().getTime();
    var BLINKFLAG = false;
    function onResults(results) {
      // console.log(results);
      var irisLeftMinX = -1;
      var irisLeftMaxX = -1;
      var width = results.image.width;
      var height = results.image.height;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          for (const point of FACEMESH_LEFT_IRIS) {
            var point0 = landmarks[point[0]];
            //console.log(point0);
              if (irisLeftMinX == -1 || point0.x * width < irisLeftMinX) {
                irisLeftMinX = point0.x * width;
              }
              if (irisLeftMaxX == -1 || point0.x * width > irisLeftMaxX) {
                  irisLeftMaxX = point0.x * width;
              }
          }
          /*for (const point of FACEMESH_RIGHT_EYE) {
            var point0 = landmarks[point[0]];
            if (irisLeftMinX == -1 || point0.x * width < irisLeftMinX) {
                irisLeftMinX = point0.x * width;
              }
              if (irisLeftMaxX == -1 || point0.x * width > irisLeftMaxX) {
                  irisLeftMaxX = point0.x * width;
              }
          }*/
          /*drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION,
                         {color: '#C0C0C070', lineWidth: 1});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {color: '#E0E0E0'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {color: '#E0E0E0'});*/
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, {color: '#30FF30'});
          var ratio = blinkRatio(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, FACEMESH_LEFT_EYE);	
          //console.log(ratio);	
          if (ratio >0.4) {	
                CEF_COUNTER +=1	
          }	
            else {	
                if (CEF_COUNTER>CLOSED_EYES_FRAME) {	
                    TOTAL_BLINKS +=1
                    BLINKFLAG = true;
                    getMinutesDifference(TOTAL_BLINKS);
                    CEF_COUNTER =0	
                }	
            }	
            // console.log(TOTAL_BLINKS);	
      
      canvasCtx.fillStyle = "green";	
      canvasCtx.font = "30px Arial";	
      canvasCtx.fillText("Blinking Count : "+TOTAL_BLINKS , width * 0.15, 50);	
      // canvasCtx.restore();
        }
      }
      var dx = irisLeftMaxX - irisLeftMinX;
      var dX = 11.7;

      // Logitech HD Pro C922	Norm focal
      var normalizedFocaleX = 1.40625;
      var fx = Math.min(width, height) * normalizedFocaleX;
      var dZ = (fx * (dX / dx)) / 10.0;
      dZ = dZ.toFixed(2);

      //console.log(dZ);
      if(dZ != 'Infinity') {
        if(dZ < 30) {
          distanceAlertCount += 1;
        }
        if(distanceAlertCount >= 10) {
          distanceNotificationTimer();
        }
      canvasCtx.fillStyle = "red";
      canvasCtx.font = "30px Arial";
      canvasCtx.fillText(dZ + " cm", width * 0.75, 50);
      canvasCtx.restore();
      }
    }
    function distanceNotificationTimer() {
          console.log("Kidnly sit back from your monitor");
          distanceAlertCount = 0;
    }
    function getMinutesDifference(totalBlinks, date = new Date()) {
        // Update the count down every 1 second
        countDownDate = new Date().getTime();
        var x = setInterval(function() {
        
        // Get today's date and time
        var now = new Date().getTime();
          console.log(countDownDate);
          console.log(now);
        // Find the distance between now and the count down date
        var distance = now - countDownDate ;
        console.log(distance);
        // Time calculations for days, hours, minutes and seconds
        var days = Math.floor(distance / (1000 * 60 * 60 * 24));
        var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        var seconds = Math.floor((distance % (1000 * 60)) / 1000);
          console.log(seconds);
          console.log(minutes);
          if(seconds >= 10) {
            console.log("Blinks");
          }
        // If the count down is over, write some text 
        if (distance < 0) {
          clearInterval(x);
          
        }
        }, 1000);
    }
    const faceMesh = new FaceMesh({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }});
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
      selfieMode: true,
      enableFaceGeometry: false,
    });
    faceMesh.onResults(onResults);
    
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({image: videoElement});
      },
      width: 1280,
      height: 720
    });
    camera.start();
    var mediaDevices = navigator.mediaDevices;
    // console.log(mediaDevices);
    function landmarksDetection(img, results) {	
    var img_width = results.image.width;	
    var img_height = results.image.height;	
    var coord = [];	
    for (const landmarks of results.multiFaceLandmarks) {	
          // console.log(landmarks);	
          var coordX = parseInt(landmarks[0].x * img_width);	
          var coordY = parseInt(landmarks[0].y * img_height);	
          //var finalCoords = '('+coordX+','+coordY+')'	
          coord.push(finalCoords)	
    }	
      // console.log(coord);	
      return coord;	
    }	
    function euclaideanDistance(point, point1) {	
      var x = point.x;	
      var y = point.y;	
      var x1 = point1.x;	
      var y1 = point1.y;	
      var distance = Math.sqrt((x1 - x)**2 + (y1 - y)**2)	
    return distance	
    }	
    function blinkRatio(img, landmarks, right_indices, left_indices){	
      // Right eyes 	
      // horizontal line 	
      var rh_right = landmarks[right_indices[0][1]];	
      var rh_left = landmarks[right_indices[8][1]];	
      var rv_top = landmarks[right_indices[12][1]];	
      var rv_bottom = landmarks[right_indices[4][1]];	
      // LEFT_EYE 	
      // horizontal line 	
      var lh_right = landmarks[left_indices[0][1]]	
      var lh_left = landmarks[left_indices[8][1]]	
      // vertical line 	
      var lv_top = landmarks[left_indices[12][1]]	
      var lv_bottom = landmarks[left_indices[4][1]]	
      var rhDistance = euclaideanDistance(rh_right, rh_left);	
      var rvDistance = euclaideanDistance(rv_top, rv_bottom)	
      var lvDistance = euclaideanDistance(lv_top, lv_bottom)	
      var lhDistance = euclaideanDistance(lh_right, lh_left)	
      var reRatio = rhDistance/rvDistance	
      var leRatio = lhDistance/lvDistance	
      var ratio = (reRatio+leRatio)/2	
      return ratio 	
    }
    </script>
    <style>

.container {
  position: absolute;
  background-color: #596e73;
  width: 100%;
  max-height: 100%;
}

.input_video {
  display: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  &.selfie {
    transform: scale(-1, 1);
  }
}

.input_image {
  position: absolute;
}

.canvas-container {
  display:flex;
  height: 100%;
  width: 100%;
  justify-content: center;
  align-items:center;
}

.output_canvas {
  max-width: 100%;
  display: block;
  position: relative;
  left: 0;
  top: 0;
}
</style>